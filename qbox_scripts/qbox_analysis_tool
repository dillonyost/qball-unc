#! /usr/bin/perl

# qbox_analysis_tool is an interactive, menu-driven analysis tool which allows a 
# user to extract different observables from a Qbox output file and display them
# either to screen or graphed in xmgrace.
#
# written by Erik Draeger, LLNL, 05/09/2008

sub print_usage {
  print "syntax:  qbox_analysis_tool [options] [Qbox output filename(s)]\n";
  print "   --lastn <value>:  number of steps displayed in convergence graphs\n";
  print "   -h, --help:  print this message\n";
  return;
}

if ($#ARGV < 0) {
  print_usage();
  exit;
}

### settings ###
$queryonexit = 0;
$delete_datfiles = 0;

### file locations ###
$gnuplot = "/usr/bin/gnuplot";
$xmgrace = "/usr/local/bin/xmgrace";
if (! -e $xmgrace) { $xmgrace = "/usr/apps/grace/5.1.21/grace/bin/xmgrace"; }
$scrollcmd = "/bin/more";     # command to view multi-page data, can be more, less, emacs, etc.

###  defaults  ###
$currtag = "etotal_int";
$currtag_index = -1;            # -1:  tag is a scalar, 0-2:  tag is a vector
$output_method_selected = 0;    # initial output method
$depvarnum = 0;                 # 0 = iteration number, 1 = wall time, 2 = simulation (MD) time
$lastnsteps = 50;               # number of steps in upper convergence graphs
$skipfirstnsteps = 0;           # ignore first X values from file

###  parse arguments for command-line options  ###
$firstarg = 0;
$argcnt = 0;
$optflag = 0;
while ($optflag == 0 && $argcnt <= $#ARGV) {
  $arg = $ARGV[$argcnt];
  if (substr($arg,0,1) eq '-') {
    $firstarg++;
    if ($arg eq '--lastn') {
      $argcnt++;
      $firstarg++;
      $lastnsteps = $ARGV[$argcnt];
    }
    if ($arg eq '--skip') {
      $argcnt++;
      $firstarg++;
      $skipfirstnsteps = $ARGV[$argcnt];
    }
    elsif ($arg eq '-h' || $arg eq '--help') {
      print_usage();
      exit;
    }
    else {
      print "Unknown option:  $arg\n";
      print_usage();
      exit;
    }
  }
  else {
    $optflag = 1;
  }
  $argcnt++;
}
$nfiles = $#ARGV + 1 - $firstarg;
$currfile = $firstarg;

### define data structures ###

$output_method[0] = {
  actionname => "Graph",
  description => "(using xmgrace)",
  action => "XmgraceGraphAction",
};
$output_method[1] = {
  actionname => "Graph",
  description => "(using gnuplot)",
  action => "GnuplotGraphAction",
};
$output_method[2] = {
  actionname => "Print",
  description => "to file",
  action => "FilePrintAction",
};
$output_method[3] = {
  actionname => "Print",
  description => "to screen",
  action => "ScreenPrintAction",
};

$depvarnames[0] = "iteration number";
$depvarnames[1] = "wall time (min)";
$depvarnames[2] = "simulation time (fs)";

$indexname[0] = 'x';
$indexname[1] = 'y';
$indexname[2] = 'z';

### define menus ###

%main_menu = (
    1 => 'Select run statements for analysis',
    2 => 'Select tag to analyze',
    3 => 'Select variable to plot against',
    4 => 'Choose output method',
    e => 'List errors and warnings',
    r => 'Run summary',
    t => 'Timing summary',
    a => "$output_method[$output_method_selected]->{actionname} $currtag vs. $depvarnames[$depvarnum] $output_method[$output_method_selected]->{description}",
    x => 'Exit');
$main_menu_prompt = 'Main Menu: ';

# keylist arrays determine the order in which menu items appear
# commenting it out will revert to alphabetic/numeric ordering
@main_menu_keylist = ('1','2','3','4','e','r','t','a','x');

if ($nfiles > 1) {
  $main_menu{'p'} = 'Previous file';
  $main_menu{'n'} = 'Next file';
  $main_menu{'j'} = 'Jump to file';
  @main_menu_keylist = ('1','2','3','4','p','n','j','e','r','t','a','x');
}

%tag_select_menu = (
     0 => 'Enter tag name',
     1 => 'etotal_int',
     2 => 'etotal',
     3 => 'econst',
     4 => 'eigenvalue_sum',
     5 => 'temp_ion',
     6 => 'a0',
     7 => 'a1',
     8 => 'a2',
     9 => 'volume',
     10 => 'pv',
     11 => 'sigma_xx',
     12 => 'sigma_yy',
     13 => 'sigma_zz',
     14 => 'sigma_xy',
     15 => 'sigma_yz',
     16 => 'sigma_xz',
     17 => 'enthalpy',
);
$tag_select_menu_prompt = 'Choose tag to analyze: ';

%output_method_menu = ();
for ($i=0; $i<=$#output_method; $i++) {
  $actionname = $output_method[$i]->{actionname};
  $desc = $output_method[$i]->{description};
  $ii = $i+1;
  $output_method_menu{$ii} = "$actionname $desc";
}
$output_method_menu_prompt = 'Choose output method: ';

for ($i=0; $i<=$#depvarnames; $i++) {
  $ii = $i+1;
  $dependent_variable_menu{$ii} = $depvarnames[$i];
}


################## Main Iteration Loop ########################

GetFileInfo($ARGV[$currfile]);
if ($nerrors == 0 && $nwarnings == 0) {
  my $offset = 0;
  for ($i=0; $i<$#main_menu_keylist; $i++) {
    if ($main_menu_keylist[$i] eq 'e') {
      splice(@main_menu_keylist,$i,1);
    }
  }
}

for ($i=0; $i<$nrun; $i++) { $run_selected[$i] = 1; }

%current_menu = %main_menu;
$current_prompt = $main_menu_prompt;
@current_keylist = @main_menu_keylist;

$choice = '';
$message = '';
MAINLOOP: while ($exitflag != 1) { 
  Clear_Screen();
  Print_Header();

  if ($message ne '') {
    print "-----------------------------------------------------------------\n";
    print "$message\n";
    print "-----------------------------------------------------------------\n\n";
    $message = '';
  }

  if (defined(@current_keylist)) {
    $selected = Pick_From_Menu(prompt => $current_prompt,menu => \%current_menu,use_keylist=>[ @current_keylist ]);
  }
  else {
    $selected = Pick_From_Menu(prompt => $current_prompt,menu => \%current_menu);
  }

  if ($current_prompt eq $main_menu_prompt) { 
    Main_Menu_Actions($selected);
  }

}

########################################################################
sub Main_Menu_Actions {

  my ($choice) = @_;

  ### select run statements to analyze ###
  if ($choice eq '1') { 
    $unseltxt = "[ ]";
    $seltxt = "[X]";
    $tempprompt = "Toggle run statement(s) to analyze: ";
    for ($i=0; $i<$nrun; $i++) {
      $ii = $i+1;
      if ($run_selected[$i] == 1) { $tempmenu{$ii} = "$seltxt run $runargs[$i]"; }
      else { $tempmenu{$ii} = "$unseltxt run $runargs[$i]"; }
      $tempkeylist[$i] = $ii;
    }
    $tempmenu{'s'} = "Select all";
    $tempmenu{'u'} = "Unselect all";
    $tempmenu{'a'} = "$output_method[$output_method_selected]->{actionname} $currtag vs. $depvarnames[$depvarnum] $output_method[$output_method_selected]->{description}";
    $tempmenu{'P'} = "Print selected run statements to file";
    $tempmenu{'b'} = "Back to main menu";
    $tempmenu{'x'} = "Exit";
    $tempkeylist[$nrun] = 's';
    $tempkeylist[$nrun+1] = 'u';
    $tempkeylist[$nrun+2] = 'a';
    $tempkeylist[$nrun+3] = 'P';
    $tempkeylist[$nrun+4] = 'b';
    $tempkeylist[$nrun+5] = 'x';

    $doneflag = 0;
    RUNSELLOOP:  while ($doneflag == 0) {
      Clear_Screen();
      Print_Header();
      if ($message ne '') {
        print "-----------------------------------------------------------------\n";
        print "$message\n";
        print "-----------------------------------------------------------------\n\n";
        $message = '';
      }
      $runkey = Pick_From_Menu(prompt => $tempprompt,menu => \%tempmenu, use_keylist=>[ @tempkeylist ], max_display=>10, return_key=>1);
      if ($runkey eq 'b') { last RUNSELLOOP; }
      elsif ($runkey eq 'u') { 
        for ($i=0; $i<$nrun; $i++) { 
          $run_selected[$i] = 0; 
          $ii = $i+1;
          $tempmenu{$ii} = "$unseltxt run $runargs[$i]";
        }
      }
      elsif ($runkey eq 's') { 
        for ($i=0; $i<$nrun; $i++) { 
          $run_selected[$i] = 1; 
          $ii = $i+1;
          $tempmenu{$ii} = "$seltxt run $runargs[$i]";
        }
      }
      elsif ($runkey eq 'a') { 
        OutputMethodAction();
      }
      elsif ($runkey eq 'P') { 
        my $currrun = -1;
        my $currmpirun = -1;
        my $printthis = 0;
        print "Enter output filename: ";
        my $outfile = <STDIN>;  chomp $outfile;
        open IN, $ARGV[$currfile] or die "Can't open $ARGV[$currfile]: $!\n";
        open OUT, ">$outfile" or die "Can't open $outfile: $!\n";
        
        INLINE: while ($line = <IN>) {
          if ($line =~ /<qbox:simulation/) { 
            $currmpirun++;
            $printthis = 0;
            for ($r=0; $r<$nrun; $r++) {
              if ($run_selected[$r] == 1) { 
                if ($mpirun_map[$r] == $currmpirun) { $printthis = 1; }
              }
            }
          }
          #elsif ($line =~ /<!--\ \[qbox\]/) { 
          elsif ($line =~ /\[qbox\]/) { 
            @data = split ' ',$line;
            for ($i=0;$i<=$#data;$i++) {
              if ($data[$i] =~ '[qbox]') {
                if ($data[$i+1] eq "run") { 
                  $printthis = 0;
                  $currrun++; 
                  if ($run_selected[$currrun] == 1) { $printthis = 1; }
                }
              }
            }
          }
          if ($printthis == 1) { print OUT $line; }
        }
        close IN;
        close OUT;
      }
      ### exit ###
      elsif ($runkey eq 'x') {
        if ($queryonexit == 1) { 
          print "Are you sure you want to exit? [n]: ";
          $answer = <STDIN>;  chomp $answer;
          unless ($answer eq 'y' || $answer eq 'Y' || $answer eq 'yes') {
            last RUNSELLOOP;
          }
        }
        $doneflag = 1;
        $exitflag = 1;
      }
      else { 
        $i = $runkey-1;
        $tmptxt = '';
        if ($run_selected[$i] == 1) { 
          $run_selected[$i] = 0;
          $tmptxt = $unseltxt;
        }
        else { 
          $run_selected[$i] = 1;
          $tmptxt = $seltxt; 
        }
        $tempmenu{$runkey} = "$tmptxt run $runargs[$i]";
      }
    }
  }

  ### select tag to analyze ###
  elsif ($choice eq '2') { 
    $currtag_index = -1;
    $tempprompt = "Choose tag to analyze: ";
    Clear_Screen();
    Print_Header();

    $currtag = Pick_From_Menu(prompt => $tempprompt,menu => \%tag_select_menu, numeric_keys=>1, max_display=>10, return_key=>0);
    if ($currtag eq $tag_select_menu{0}) {
      print "Enter tag to analyze: ";
      $input = <STDIN>; chomp $input;
      $currtag = $input;
    }
    if ($currtag eq "a0" || $currtag eq "a1" || $currtag eq "a2") { 
      print "Enter vector component of $currtag (x, y, or z):  ";
      $input = <STDIN>;  chomp $input;
      if ($input eq 'x') { $currtag_index = 0; }
      elsif ($input eq 'y') { $currtag_index = 1; }
      elsif ($input eq 'z') { $currtag_index = 2; }
      else { $message = "Invalid selection!"; }
    }
    $main_menu{'a'} = "$output_method[$output_method_selected]->{actionname} $currtag vs. $depvarnames[$depvarnum] $output_method[$output_method_selected]->{description}";
    %current_menu = %main_menu;
  }

  ### select variable to plot against ###
  elsif ($choice eq '3') { 
    $tempprompt = "$output_method[$output_method_selected]->{actionname} $currtag:";
    Clear_Screen();
    Print_Header();
    $depvarchoice = Pick_From_Menu(prompt => $tempprompt,menu => \%dependent_variable_menu, numeric_keys=>1, max_display=>10, return_key=>0);

    for ($i=0; $i<=$#depvarnames; $i++) {
      $ii = $i+1;
      if ($depvarchoice eq $dependent_variable_menu{$ii}) {
        $depvarnum = $i;
      }
    }
    $main_menu{'a'} = "$output_method[$output_method_selected]->{actionname} $currtag vs. $depvarnames[$depvarnum] $output_method[$output_method_selected]->{description}";
    %current_menu = %main_menu;
    $current_prompt = $main_menu_prompt;
    @current_keylist = @main_menu_keylist;
  }

  ### choose output method ###
  elsif ($choice eq '4') { 
    $tempprompt = "Choose output method: ";
    Clear_Screen();
    Print_Header();

    $outputchoice = Pick_From_Menu(prompt => $tempprompt,menu => \%output_method_menu, numeric_keys=>1, max_display=>10, return_key=>0);
    for ($i=0; $i<=$#output_method; $i++) {
      $ii = $i+1;
      if ($outputchoice eq $output_method_menu{$ii}) {
        $output_method_selected = $i;
      }
    }
    $main_menu{'a'} = "$output_method[$output_method_selected]->{actionname} $currtag vs. $depvarnames[$depvarnum] $output_method[$output_method_selected]->{description}";
    %current_menu = %main_menu;
    $current_prompt = $main_menu_prompt;
    @current_keylist = @main_menu_keylist;
  }

  ### list errors and warnings ###
  elsif ($choice eq 'e') { 
    $message = '';
    if ($nerrors > 0) { 
      $message = join '',$message,"Errors:\n";
      for ($r=0; $r<$nrun; $r++) {
        $message = join '',$message,"  run $runargs[$r]:\n";
        for ($i=0; $i<$nerrors; $i++) {
          if ($errorrun[$i] == $r) {
            $message = join '',$message,"   ",$errorlist[$i],"\n";
          }
        }
      }
    }
    if ($nwarnings > 0) { 
      $message = join '',$message,"Warnings:\n";
      for ($r=0; $r<$nrun; $r++) {
        $message = join '',$message,"  run $runargs[$r]:\n";
        for ($i=0; $i<$nwarnings; $i++) {
          if ($warningrun[$i] == $r) {
            $message = join '',$message,"   ",$warninglist[$i],"\n";
          }
        }
      }
    }
    if ($nerrors == 0 && $nwarnings == 0) { 
      $message = "No errors or warnings found.";
    }


  }

  ### load previous file ###
  elsif ($choice eq 'p' && $nfiles > 1) {
    if ($currfile > 0) { 
      $currfile--;
      GetFileInfo($ARGV[$currfile]);
      for ($i=0; $i<$nrun; $i++) { $run_selected[$i] = 1; }
    }
  }

  ### load next file ###
  elsif ($choice eq 'n' && $nfiles > 1) {
    if ($currfile < $#ARGV) { 
      $currfile++;
      GetFileInfo($ARGV[$currfile]);
      for ($i=0; $i<$nrun; $i++) { $run_selected[$i] = 1; }
    }
  }

  ### jump to file ###
  elsif ($choice eq 'j' && $nfiles > 1) {  
    print "Enter file number: ";
    $jumpfile = <STDIN>;  chomp $jumpfile;
    $jumpfile = int $jumpfile;
    $jumpfile--;
    if ($jumpfile >= 0 && $jumpfile <= $#ARGV) {
      $currfile = $jumpfile;
      GetFileInfo($ARGV[$currfile]);
      for ($i=0; $i<$nrun; $i++) { $run_selected[$i] = 1; }
    }
  }

  ### run summary ###
  elsif ($choice eq 'r') {
    PrintRunSummary($ARGV[$currfile]);
  }

  ### timing summary ###
  elsif ($choice eq 't') {
    PrintTimingSummary($ARGV[$currfile]);
  }

  ### perform output method action ###
  elsif ($choice eq 'a') { 
    OutputMethodAction();
  }

  ### exit ###
  elsif ($choice eq 'x') {
    if ($queryonexit == 1) { 
      print "Are you sure you want to exit? [n]: ";
      $answer = <STDIN>;  chomp $answer;
      unless ($answer eq 'y' || $answer eq 'Y' || $answer eq 'yes') {
        next MAINLOOP;
      }
    }
    $exitflag = 1;
  }

}
########################################################################
sub OutputMethodAction {
  my $runselcnt = 0;
  for ($i=0; $i<$nrun; $i++) { 
    if ($run_selected[$i] == 1) { $runselcnt++; }
  }
  if ($runselcnt > 0) { &{$output_method[$output_method_selected]->{action}}; }
  else { $message = "No run statements selected!"; }
}
########################################################################
sub XmgraceGraphAction {

  if (! -e $xmgrace) { 
    $message = "$xmgrace not found!";
    return;
  }
  my @tag = GetTagFromFile($currtag,$currtag_index,$ARGV[$currfile]);
  my $tagsize = @tag - 1;
  my $tmptag = $currtag;
  my $lasttagval = $tag[$tagsize-1][3];
  if ($currtag_index == 0) { $tmptag = join '',$tmptag,'x'; }
  elsif ($currtag_index == 1) { $tmptag = join '',$tmptag,'y'; }
  elsif ($currtag_index == 2) { $tmptag = join '',$tmptag,'z'; }
  $plotfile1 = join '',$ARGV[$currfile],'.',$tmptag,'.ionic.dat';
  $plotfile2 = join '',$ARGV[$currfile],'.',$tmptag,'.scf.dat';
  $plotfile3 = join '',$ARGV[$currfile],'.',$tmptag,'.nonscf.dat';
  open PLOT1, ">$plotfile1";
  print PLOT1 "\#  $depvarnames[$depvarnum]  $tmptag\n";
  open PLOT2, ">$plotfile2";
  print PLOT2 "\#  $depvarnames[$depvarnum]  $tmptag\n";
  open PLOT3, ">$plotfile3";
  print PLOT3 "\#  $depvarnames[$depvarnum]  $tmptag\n";
  $errfile1 = join '',$ARGV[$currfile],'.',$tmptag,'.ionic.err.dat';
  $errfile2 = join '',$ARGV[$currfile],'.',$tmptag,'.scf.err.dat';
  $errfile3 = join '',$ARGV[$currfile],'.',$tmptag,'.nonscf.err.dat';
  open ERR1, ">$errfile1";
  print ERR1 "\#  $depvarnames[$depvarnum]  $tmptag - $lasttagval\n";
  open ERR2, ">$errfile2";
  print ERR2 "\#  $depvarnames[$depvarnum]  $tmptag - $lasttagval\n";
  open ERR3, ">$errfile3";
  print ERR3 "\#  $depvarnames[$depvarnum]  $tmptag - $lasttagval\n";
  my $lastionictime = -1;
  my $tmpdt = 0.0;
  my $deltat = 0.0;
  my $cnt1 = 0;
  my $cnt2 = 0;
  my $cnt3 = 0;


  if ($skipfirstnsteps >= $tagsize) { $message = "--skip value = $skipfirstnsteps is larger than total number of $tmptag values!";  return; } 
  my $xmin = $tag[$skipfirstnsteps][$depvarnum];  my $xmax = $tag[$skipfirstnsteps][$depvarnum];  
  if ($depvarnum == 1) { $xmin /= 60; $xmax /= 60; }
  my $ymin = $tag[$skipfirstnsteps][3];  my $ymax = $tag[$skipfirstnsteps][3];

  my $last0 = $skipfirstnsteps;
  if (($tagsize-$skipfirstnsteps) > $lastnsteps) { $last0 = $tagsize - $lastnsteps; }
  my $xmin2 = $tag[$last0][$depvarnum];  my $xmax2 = $tag[$last0][$depvarnum];  
  if ($depvarnum == 1) { $xmin2 /= 60; $xmax2 /= 60; }
  my $ymin2 = $tag[$last0][3];  my $ymax2 = $tag[$last0][3];
  my $ymin3 = 1000000000.0;  my $ymax3 = 1.E-11;
  
  for ($i=0; $i<$tagsize; $i++) {

    my $time = $tag[$i][$depvarnum];
    if ($depvarnum == 1) { $time /= 60; }

    if ($tag[$i][4] eq "ionic") { 
      $tmpdt = 0.0;
      $lastionictime = $time;
      INNER1:  for ($j=$i+1; $j<=$tagsize; $j++) {
        if ($tag[$j][4] eq "ionic") { 
          $newtime = $tag[$j][$depvarnum];
          if ($depvarnum == 1) { $newtime /= 60; }
          $deltat = ($newtime - $lastionictime)/($j-$i);
          last INNER1;
        }
      }
    }
    else {
      $tmpdt += $deltat;
      if ($depvarnum == 1 || $depvarnum == 2) { 
        $time = $lastionictime + $tmpdt;
      }
    }

    if ($i >= $skipfirstnsteps) { 

      my $errval = abs($tag[$i][3]-$lasttagval); 
      if ($errval == 0.0) { $errval = 1.E-9; }
      if ($tag[$i][4] eq "ionic") { 
        $cnt1++; 
        printf PLOT1 " %0.8f    %0.10f \n",$time,$tag[$i][3]; 
        printf ERR1 " %0.8f    %0.10f \n",$time,$errval; 
      }
      elsif ($tag[$i][4] eq "scf") { 
        $cnt2++; 
        printf PLOT2 " %0.8f    %0.10f \n",$time,$tag[$i][3]; 
        printf ERR2 " %0.8f    %0.10f \n",$time,$errval;
      }
      elsif ($tag[$i][4] eq "nonscf") { 
        $cnt3++; 
        printf PLOT3 " %0.8f    %0.10f \n",$time,$tag[$i][3]; 
        printf ERR3 " %0.8f    %0.10f \n",$time,$errval;
      }
      if ($time > $xmax) { $xmax = $time; }
      if ($time < $xmin) { $xmin = $time; }
      if ($tag[$i][3] > $ymax) { $ymax = $tag[$i][3]; }
      if ($tag[$i][3] < $ymin) { $ymin = $tag[$i][3]; }
      
      if ($i > $last0) { 
        if ($time > $xmax2) { $xmax2 = $time; }
        if ($time < $xmin2) { $xmin2 = $time; }
        if ($tag[$i][3] > $ymax2) { $ymax2 = $tag[$i][3]; }
        if ($tag[$i][3] < $ymin2) { $ymin2 = $tag[$i][3]; }
        if ($errval > $ymax3) { $ymax3 = $errval; }
        if ($errval < $ymin3) { $ymin3 = $errval; }
      }
    }
  }
  close PLOT1;
  close PLOT2;
  close PLOT3;

  $xrange = abs($xmax - $xmin);
  $yrange = abs($ymax - $ymin);
  $ymin -= 0.10*$yrange;
  $xmax += 0.05*$xrange;
  $ymax += 0.05*$yrange;
  $xrange = abs($xmax - $xmin);
  $yrange = abs($ymax - $ymin);
  $deltax = sprintf "%0.1e",$xrange/5;
  $deltay = sprintf "%0.1e",$yrange/5;

  #$xmax2 += 0.02*abs($xmax2);
  my $equalflag2 = 0;
  if ($ymin2 == $ymax2) { 
    $equalflag2 = 1;
    $ymin2 -= 1.E-8;
    $ymax2 += 1.E-8;
  }
  if ($ymin3 == $ymax3) { 
    $ymin3 = 1.00E-10;
    $ymax3 = 1.00E-8;
  }
  $xrange2 = abs($xmax2 - $xmin2);
  $yrange2 = abs($ymax2 - $ymin2);
  $ymin2 -= 0.2*$yrange2;
  $deltax2 = sprintf "%0.1e",$xrange2/5;
  $deltay2 = sprintf "%0.1e",$yrange2/5;
  $deltay3 = 10.0;  # log spacing

  ### set xmgrace graph appearance options ###
  $xmgroptfile = join '',$plotfile1,'.xmgropts.tmp';
  open PLOTOPTS, ">$xmgroptfile";
  print PLOTOPTS "with string\n";
  print PLOTOPTS " string on\n";
  print PLOTOPTS " string loctype view\n";
  print PLOTOPTS " string font 0\n";
  print PLOTOPTS " string color 1\n";
  print PLOTOPTS " string char size 1.0\n";
  print PLOTOPTS " string 0.23, 0.76\n";
  if ($equalflag2 == 0) { printf PLOTOPTS " string def \"range = %0.2e\"\n",$yrange2; }
  else { printf PLOTOPTS " string def \"range < 1.00E-9\"\n"; }
  print PLOTOPTS "with string\n";
  print PLOTOPTS " string on\n";
  print PLOTOPTS " string loctype view\n";
  print PLOTOPTS " string font 0\n";
  print PLOTOPTS " string color 1\n";
  print PLOTOPTS " string char size 1.0\n";
  print PLOTOPTS " string 0.91, 0.59\n";
  if ($equalflag2 == 0) { printf PLOTOPTS " string def \"range = %0.2e\"\n",$yrange2; }
  else { printf PLOTOPTS " string def \"range < 1.00E-9\"\n"; }
  # put arrowed lines showing spread
  if ($equalflag2 == 0) {
    print PLOTOPTS "with line\n";
    print PLOTOPTS " line on\n";
    print PLOTOPTS " line loctype view\n";
    print PLOTOPTS " line 0.18, 0.83, 0.18, 0.58\n";
    print PLOTOPTS " line linewidth 2.0\n";
    print PLOTOPTS " line color 1\n";
    print PLOTOPTS " line arrow 3\n";
    print PLOTOPTS " line arrow type 1\n";
    print PLOTOPTS " line arrow length 1.0\n";
    print PLOTOPTS " line arrow layout 1.0, 1.0\n";
    print PLOTOPTS " line def\n";
    print PLOTOPTS "with line\n";
    print PLOTOPTS " line on\n";
    print PLOTOPTS " line loctype view\n";
    print PLOTOPTS " line 1.11, 0.83, 1.11, 0.58\n";
    print PLOTOPTS " line linewidth 2.0\n";
    print PLOTOPTS " line color 1\n";
    print PLOTOPTS " line arrow 3\n";
    print PLOTOPTS " line arrow type 1\n";
    print PLOTOPTS " line arrow length 1.0\n";
    print PLOTOPTS " line arrow layout 1.0, 1.0\n";
    print PLOTOPTS " line def\n";
  }
  print PLOTOPTS "g0 on\n";
  print PLOTOPTS "with g0\n";
  print PLOTOPTS "  legend off\n";
  print PLOTOPTS "  view 0.150000, 0.531818, 0.602244, 0.850000\n";
#  print PLOTOPTS "title \"$ARGV[$currfile]\"\n";
  print PLOTOPTS "subtitle \"last $lastnsteps values, linear\"\n";
#  print PLOTOPTS "subtitle size 1.25 \n";
#  print PLOTOPTS "xaxis label \"$depvarnames[$depvarnum]\"\n";
  print PLOTOPTS "yaxis label \"$tmptag\"\n";
  print PLOTOPTS "xaxis label char size 1.0 \n";
  print PLOTOPTS "yaxis label char size 1.0 \n";
  print PLOTOPTS "xaxis tick major linewidth 2.0 \n";
  print PLOTOPTS "xaxis tick minor linewidth 2.0 \n";
  print PLOTOPTS "yaxis tick major linewidth 2.0 \n";
  print PLOTOPTS "yaxis tick minor linewidth 2.0 \n";
  print PLOTOPTS "world $xmin2, $ymin2, $xmax2, $ymax2 \n";
  print PLOTOPTS "xaxis tick major $deltax2 \n";
  print PLOTOPTS "yaxis tick major $deltay2 \n";
  print PLOTOPTS "xaxis ticklabel char size 0.75 \n";
  print PLOTOPTS "yaxis ticklabel char size 0.75 \n";
  print PLOTOPTS "xaxis tick minor ticks 4\n";
  print PLOTOPTS "yaxis tick minor ticks 4\n";
  print PLOTOPTS "frame linewidth 2\n";
  print PLOTOPTS "s0 symbol 1\n";
  print PLOTOPTS "s0 legend \"ionic\"\n";
  print PLOTOPTS "s0 symbol fill pattern 1\n";
#  print PLOTOPTS "s0 linewidth 2\n";  
  print PLOTOPTS "s0 linewidth 0\n";  
  print PLOTOPTS "s0 linestyle 0\n";
  print PLOTOPTS "s0 symbol color 1\n";         # 1 = black, 2 = red, 3 = green, 4 = blue
  print PLOTOPTS "s0 line color 2\n";           # 5 = brown, 6 = yellow, 7 = purple, 8 = grey
  print PLOTOPTS "s0 symbol fill color 1\n";
  print PLOTOPTS "s0 symbol size 0.50\n";

  $set2 = "s1";
  $set3 = "s2";
  $s2color = "2";
  $s3color = "3";
  $s2size = "0.35";
  $s3size = "0.30";
  $s2name = "scf";
  $s3name = "non-scf";
  if ($cnt2 == 0) { 
    $set3 = $set2; 
    $s3color = $s2color;
    $s3size = $s2size;
    $s3name = $s2name;
  }

  if ($cnt2 > 0) { 
    print PLOTOPTS "$set2 symbol 2\n";
    print PLOTOPTS "$set2 legend \"$s2name\"\n";
    print PLOTOPTS "$set2 symbol fill pattern 1\n";
    print PLOTOPTS "$set2 linewidth 0\n";  
    print PLOTOPTS "$set2 linestyle 0\n";
    print PLOTOPTS "$set2 symbol color $s2color\n";         # 1 = black, 2 = red, 3 = green, 4 = blue
    print PLOTOPTS "$set2 line color $s2color\n";           # 5 = brown, 6 = yellow, 7 = purple, 8 = grey
    print PLOTOPTS "$set2 symbol fill color $s2color\n";
    print PLOTOPTS "$set2 symbol size $s2size\n";
  }
  if ($cnt3 > 0) { 
    print PLOTOPTS "$set3 symbol 3\n";
    print PLOTOPTS "$set3 legend \"$s3name\"\n";
    print PLOTOPTS "$set3 symbol fill pattern 1\n";
    print PLOTOPTS "$set3 linewidth 0\n";  
    print PLOTOPTS "$set3 linestyle 0\n";
    print PLOTOPTS "$set3 symbol color $s3color\n";         # 1 = black, 2 = red, 3 = green, 4 = blue
    print PLOTOPTS "$set3 line color $s3color\n";           # 5 = brown, 6 = yellow, 7 = purple, 8 = grey
    print PLOTOPTS "$set3 symbol fill color $s3color\n";
    print PLOTOPTS "$set3 symbol size $s3size\n";
  }
  print PLOTOPTS "g1 on\n";
  print PLOTOPTS "with g1\n";
  print PLOTOPTS "  legend off\n";
  print PLOTOPTS "  view 0.692693, 0.531818, 1.144937, 0.850000\n";
#  print PLOTOPTS "title \"$ARGV[$currfile]\"\n";
  print PLOTOPTS "subtitle \"last $lastnsteps values, log\"\n";
#  print PLOTOPTS "subtitle size 1.25 \n";
#  print PLOTOPTS "xaxis label \"$depvarnames[$depvarnum]\"\n";
#  print PLOTOPTS "altyaxis on\n";
#  print PLOTOPTS "altyaxis label \"log($tmptag - last value)\"\n";
#  print PLOTOPTS "altyaxis label place opposite\n";
#  print PLOTOPTS "yaxis label \"$tmptag\"\n";
  print PLOTOPTS "yaxis label \"log($tmptag - last value)\"\n";
  print PLOTOPTS "xaxis label char size 1.0 \n";
  print PLOTOPTS "yaxis label char size 1.0 \n";
  print PLOTOPTS "xaxis tick major linewidth 2.0 \n";
  print PLOTOPTS "xaxis tick minor linewidth 2.0 \n";
  print PLOTOPTS "yaxis tick major linewidth 2.0 \n";
  print PLOTOPTS "yaxis tick minor linewidth 2.0 \n";
  print PLOTOPTS "world $xmin2, $ymin3, $xmax2, $ymax3 \n";
  print PLOTOPTS "yaxis ticklabel place opposite \n";
  print PLOTOPTS "xaxis tick major $deltax2 \n";
  print PLOTOPTS "yaxis tick major $deltay3 \n";
  print PLOTOPTS "xaxis ticklabel char size 0.75 \n";
  print PLOTOPTS "yaxis ticklabel char size 0.75 \n";
  print PLOTOPTS "xaxis tick minor ticks 4\n";
  print PLOTOPTS "yaxis tick minor ticks 4\n";
  print PLOTOPTS "frame linewidth 2\n";
  print PLOTOPTS "s0 symbol 1\n";
  print PLOTOPTS "s0 legend \"ionic\"\n";
  print PLOTOPTS "s0 symbol fill pattern 1\n";
#  print PLOTOPTS "s0 linewidth 2\n";  
  print PLOTOPTS "s0 linewidth 0\n";  
  print PLOTOPTS "s0 linestyle 0\n";
  print PLOTOPTS "s0 symbol color 1\n";         # 1 = black, 2 = red, 3 = green, 4 = blue
  print PLOTOPTS "s0 line color 2\n";           # 5 = brown, 6 = yellow, 7 = purple, 8 = grey
  print PLOTOPTS "s0 symbol fill color 1\n";
  print PLOTOPTS "s0 symbol size 0.50\n";
  if ($cnt2 > 0) { 
    print PLOTOPTS "$set2 symbol 2\n";
    print PLOTOPTS "$set2 legend \"$s2name\"\n";
    print PLOTOPTS "$set2 symbol fill pattern 1\n";
    print PLOTOPTS "$set2 linewidth 0\n";  
    print PLOTOPTS "$set2 linestyle 0\n";
    print PLOTOPTS "$set2 symbol color $s2color\n";         # 1 = black, 2 = red, 3 = green, 4 = blue
    print PLOTOPTS "$set2 line color $s2color\n";           # 5 = brown, 6 = yellow, 7 = purple, 8 = grey
    print PLOTOPTS "$set2 symbol fill color $s2color\n";
    print PLOTOPTS "$set2 symbol size $s2size\n";
  }
  if ($cnt3 > 0) { 
    print PLOTOPTS "$set3 symbol 3\n";
    print PLOTOPTS "$set3 legend \"$s3name\"\n";
    print PLOTOPTS "$set3 symbol fill pattern 1\n";
    print PLOTOPTS "$set3 linewidth 0\n";  
    print PLOTOPTS "$set3 linestyle 0\n";
    print PLOTOPTS "$set3 symbol color $s3color\n";         # 1 = black, 2 = red, 3 = green, 4 = blue
    print PLOTOPTS "$set3 line color $s3color\n";           # 5 = brown, 6 = yellow, 7 = purple, 8 = grey
    print PLOTOPTS "$set3 symbol fill color $s3color\n";
    print PLOTOPTS "$set3 symbol size $s3size\n";
  }
  print PLOTOPTS "g2 on\n";
  print PLOTOPTS "with g2\n";
  print PLOTOPTS "  view 0.150000, 0.150000, 1.150000, 0.468182\n";
#  print PLOTOPTS "title \"$ARGV[$currfile]\"\n";
#  print PLOTOPTS "subtitle \"$tmptag vs. $depvarnames[$depvarnum]\"\n";
#  print PLOTOPTS "subtitle size 1.25 \n";
  print PLOTOPTS "xaxis label \"$depvarnames[$depvarnum]\"\n";
  print PLOTOPTS "yaxis label \"$tmptag\"\n";
  print PLOTOPTS "xaxis label char size 1.0 \n";
  print PLOTOPTS "yaxis label char size 1.0 \n";
  print PLOTOPTS "xaxis tick major linewidth 2.0 \n";
  print PLOTOPTS "xaxis tick minor linewidth 2.0 \n";
  print PLOTOPTS "yaxis tick major linewidth 2.0 \n";
  print PLOTOPTS "yaxis tick minor linewidth 2.0 \n";
  print PLOTOPTS "world $xmin, $ymin, $xmax, $ymax \n";
  print PLOTOPTS "xaxis tick major $deltax \n";
  print PLOTOPTS "yaxis tick major $deltay \n";
  print PLOTOPTS "xaxis ticklabel char size 0.75 \n";
  print PLOTOPTS "yaxis ticklabel char size 0.75 \n";
  print PLOTOPTS "xaxis tick minor ticks 4\n";
  print PLOTOPTS "yaxis tick minor ticks 4\n";
  print PLOTOPTS "frame linewidth 2\n";
  print PLOTOPTS "s0 symbol 1\n";
  print PLOTOPTS "s0 legend \"ionic\"\n";
  print PLOTOPTS "s0 symbol fill pattern 1\n";
#  print PLOTOPTS "s0 linewidth 2\n";  
  print PLOTOPTS "s0 linewidth 0\n";  
  print PLOTOPTS "s0 linestyle 0\n";
  print PLOTOPTS "s0 symbol color 1\n";         # 1 = black, 2 = red, 3 = green, 4 = blue
  print PLOTOPTS "s0 line color 2\n";           # 5 = brown, 6 = yellow, 7 = purple, 8 = grey
  print PLOTOPTS "s0 symbol fill color 1\n";
  print PLOTOPTS "s0 symbol size 0.50\n";
  if ($cnt2 > 0) { 
    print PLOTOPTS "$set2 symbol 2\n";
    print PLOTOPTS "$set2 legend \"$s2name\"\n";
    print PLOTOPTS "$set2 symbol fill pattern 1\n";
    print PLOTOPTS "$set2 linewidth 0\n";  
    print PLOTOPTS "$set2 linestyle 0\n";
    print PLOTOPTS "$set2 symbol color $s2color\n";         # 1 = black, 2 = red, 3 = green, 4 = blue
    print PLOTOPTS "$set2 line color $s2color\n";           # 5 = brown, 6 = yellow, 7 = purple, 8 = grey
    print PLOTOPTS "$set2 symbol fill color $s2color\n";
    print PLOTOPTS "$set2 symbol size $s2size\n";
  }
  if ($cnt3 > 0) { 
    print PLOTOPTS "$set3 symbol 3\n";
    print PLOTOPTS "$set3 legend \"$s3name\"\n";
    print PLOTOPTS "$set3 symbol fill pattern 1\n";
    print PLOTOPTS "$set3 linewidth 0\n";  
    print PLOTOPTS "$set3 linestyle 0\n";
    print PLOTOPTS "$set3 symbol color $s3color\n";         # 1 = black, 2 = red, 3 = green, 4 = blue
    print PLOTOPTS "$set3 line color $s3color\n";           # 5 = brown, 6 = yellow, 7 = purple, 8 = grey
    print PLOTOPTS "$set3 symbol fill color $s3color\n";
    print PLOTOPTS "$set3 symbol size $s3size\n";
  }
  print PLOTOPTS "legend on\n";
  print PLOTOPTS "legend loctype view\n";
  print PLOTOPTS "legend 0.96, 0.45\n";
  print PLOTOPTS "legend box color 1\n";
  print PLOTOPTS "legend box pattern 1\n";
  print PLOTOPTS "legend box linewidth 2.0\n";
  print PLOTOPTS "legend box fill color 0\n";
  print PLOTOPTS "legend box fill pattern 1\n";
  print PLOTOPTS "legend font 0\n";
  print PLOTOPTS "legend char size 0.75\n";
  print PLOTOPTS "legend length 4\n";
  print PLOTOPTS "legend vgap 1\n";
  print PLOTOPTS "legend hgap 1\n";
  close PLOTOPTS;

  $plotlist = "-graph 0 -block $plotfile1 -bxy 1:2";
  if ($cnt2 > 0) { 
    $plotlist = join '',$plotlist," -block $plotfile2 -bxy 1:2";
  }
  if ($cnt3 > 0) { 
    $plotlist = join '',$plotlist," -block $plotfile3 -bxy 1:2";
  }

  $plotlist = join '',$plotlist," -graph 1 -log y -block $errfile1 -bxy 1:2";
  if ($cnt2 > 0) { 
    $plotlist = join '',$plotlist," -block $errfile2 -bxy 1:2";
  }
  if ($cnt3 > 0) { 
    $plotlist = join '',$plotlist," -block $errfile3 -bxy 1:2";
  }

  $plotlist = join '',$plotlist," -graph 2 -block $plotfile1 -bxy 1:2";
  if ($cnt2 > 0) { 
    $plotlist = join '',$plotlist," -block $plotfile2 -bxy 1:2";
  }
  if ($cnt3 > 0) { 
    $plotlist = join '',$plotlist," -block $plotfile3 -bxy 1:2";
  }
  $xmgr_cmd = join '',$xmgrace," -noask $plotlist -batch $xmgroptfile";
  system("$xmgr_cmd");

  unlink $xmgroptfile;

  if ($delete_datfiles == 1) {
    unlink $plotfile1;
    unlink $plotfile2;
    unlink $plotfile3;
    unlink $errfile1;
    unlink $errfile2;
    unlink $errfile3;
  }
  elsif ($cnt2 == 0 || $cnt3 == 0) { 
    if ($cnt2 == 0) { unlink $plotfile2; }
    if ($cnt3 == 0) { unlink $plotfile3; }
  }

}
########################################################################
sub GnuplotGraphAction {

  if (! -e $gnuplot) { 
    $message = "$gnuplot not found!";
    return;
  }
  $gnuplotcmd = "$gnuplot -geometry 800x600 -persist";

  my @tag = GetTagFromFile($currtag,$currtag_index,$ARGV[$currfile]);
  my $tmptag = $currtag;
  if ($currtag_index == 0) { $tmptag = join '',$tmptag,'x'; }
  elsif ($currtag_index == 1) { $tmptag = join '',$tmptag,'y'; }
  elsif ($currtag_index == 2) { $tmptag = join '',$tmptag,'z'; }
  $plotfile1 = join '',$ARGV[$currfile],'.',$tmptag,'.ionic.dat';
  $plotfile2 = join '',$ARGV[$currfile],'.',$tmptag,'.scf.dat';
  $plotfile3 = join '',$ARGV[$currfile],'.',$tmptag,'.nonscf.dat';
  open PLOT1, ">$plotfile1";
  print PLOT1 "\#  $depvarnames[$depvarnum]  $tmptag\n";
  open PLOT2, ">$plotfile2";
  print PLOT2 "\#  $depvarnames[$depvarnum]  $tmptag\n";
  open PLOT3, ">$plotfile3";
  print PLOT3 "\#  $depvarnames[$depvarnum]  $tmptag\n";
  my $tagsize = @tag - 1;
  my $lastionictime = -1;
  my $tmpdt = 0.0;
  my $deltat = 0.0;
  my $cnt1 = 0;
  my $cnt2 = 0;
  my $cnt3 = 0;
  for ($i=0; $i<$tagsize; $i++) {

    my $time = $tag[$i][$depvarnum];
    if ($depvarnum == 1) { $time /= 60; }

    if ($i==0) {
      $xmin = $time;  $xmax = $time;
      $ymin = 0;  $ymax = 0;
    }

    if ($tag[$i][4] eq "ionic") { 
      $tmpdt = 0.0;
      $lastionictime = $time;
      INNER1:  for ($j=$i+1; $j<=$tagsize; $j++) {
        if ($tag[$j][4] eq "ionic") { 
          $newtime = $tag[$j][$depvarnum];
          if ($depvarnum == 1) { $newtime /= 60; }
          $deltat = ($newtime - $lastionictime)/($j-$i);
          last INNER1;
        }
      }
    }
    else {
      $tmpdt += $deltat;
      if ($depvarnum == 1 || $depvarnum == 2) { 
        $time = $lastionictime + $tmpdt;
      }
    }

    if ($tag[$i][4] eq "ionic") { $cnt1++; printf PLOT1 " %0.8f    %0.10f \n",$time,$tag[$i][3]; }
    elsif ($tag[$i][4] eq "scf") { $cnt2++; printf PLOT2 " %0.8f    %0.10f \n",$time,$tag[$i][3]; }
    elsif ($tag[$i][4] eq "nonscf") { $cnt3++; printf PLOT3 " %0.8f    %0.10f \n",$time,$tag[$i][3]; }
    if ($time > $xmax) { $xmax = $time; }
    if ($time < $xmin) { $xmin = $time; }
    if ($tag[$i][3] > $ymax) { $ymax = $tag[$i][3]; }
    if ($tag[$i][3] < $ymin) { $ymin = $tag[$i][3]; }
  }
  close PLOT1;
  close PLOT2;
  close PLOT3;

  $ymin -= 0.10*abs($ymin);
  $xmax += 0.05*abs($xmax);
  $ymax += 0.05*abs($ymax);

  # plot with gnuplot
  $gnufile = join '',$plotfile1,'.gnuplotopts.tmp';
  open GNUPLOT, ">$gnufile";

  print GNUPLOT "set terminal x11 font \"Helvetica,18\"\n";
#  print GNUPLOT "set output \"$psfile\"\n";
  print GNUPLOT "set style data points\n";
  print GNUPLOT "set lmargin 6\n";
  print GNUPLOT "set grid\n";
  print GNUPLOT "set xrange [$xmin:$xmax]\n";
  print GNUPLOT "set yrange [$ymin:$ymax]\n";
  print GNUPLOT "set size 0.95, 1.0\n";    
  print GNUPLOT "set origin 0.05,0.0\n";
  print GNUPLOT "set xlabel \'$depvarnames[$depvarnum]\'\n";
  print GNUPLOT "set ylabel \'$tmptag\'\n";
  print GNUPLOT "set xzeroaxis lt -1\n";


  $plotlist = "plot \"$plotfile1\" title \"ionic\" w points pt 1 ps 1";
  if ($cnt2 > 0) { 
    $plotlist = join '',$plotlist,", \"$plotfile2\" title \"scf\" w points pt 2 ps 1";
    if ($cnt3 > 0) { 
      $plotlist = join '',$plotlist,", \"$plotfile3\" title \"non-scf\" w points pt 3 ps 1";
    }
  }

  print GNUPLOT "$plotlist\n";
  $return = system("$gnuplotcmd $gnufile");
  unless ($return == 0) { 
    print "Error running gnuplot\n";
    exit;
  }
  unlink($gnufile);

  if ($delete_datfiles == 1) {
    unlink $plotfile1;
    unlink $plotfile2;
    unlink $plotfile3;
  }
  elsif ($cnt2 == 0 || $cnt3 == 0) { 
    if ($cnt2 == 0) { unlink $plotfile2; }
    if ($cnt3 == 0) { unlink $plotfile3; }
  }
}
########################################################################
sub FilePrintAction {

  my @tag = GetTagFromFile($currtag,$currtag_index,$ARGV[$currfile]);
  my $tmptag = $currtag;
  if ($currtag_index == 0) { $tmptag = join '',$tmptag,'x'; }
  elsif ($currtag_index == 1) { $tmptag = join '',$tmptag,'y'; }
  elsif ($currtag_index == 2) { $tmptag = join '',$tmptag,'z'; }
  $plotfile1 = join '',$ARGV[$currfile],'.',$tmptag,'.dat';
  open PLOT1, ">$plotfile1";
  print PLOT1 "\#  $depvarnames[$depvarnum]  $tmptag\n";
  my $tagsize = @tag - 1;
  my $lastionictime = -1;
  my $tmpdt = 0.0;
  my $deltat = 0.0;
  my $cnt1 = 0;
  my $cnt2 = 0;
  my $cnt3 = 0;
  for ($i=0; $i<$tagsize; $i++) {

    my $time = $tag[$i][$depvarnum];
    if ($depvarnum == 1) { $time /= 60; }

    if ($i==0) {
      $xmin = $time;  $xmax = $time;
      $ymin = 0;  $ymax = 0;
    }

    if ($tag[$i][4] eq "ionic") { 
      $tmpdt = 0.0;
      $lastionictime = $time;
      INNER1:  for ($j=$i+1; $j<=$tagsize; $j++) {
        if ($tag[$j][4] eq "ionic") { 
          $newtime = $tag[$j][$depvarnum];
          if ($depvarnum == 1) { $newtime /= 60; }
          $deltat = ($newtime - $lastionictime)/($j-$i);
          last INNER1;
        }
      }
    }
    else {
      $tmpdt += $deltat;
      if ($depvarnum == 1 || $depvarnum == 2) { 
        $time = $lastionictime + $tmpdt;
      }
    }
    printf PLOT1 " %0.8f    %0.10f \n",$time,$tag[$i][3];
  }
  close PLOT1;

  $message = "$tmptag printed to $plotfile1";

}
########################################################################
sub ScreenPrintAction {

  my @tag = GetTagFromFile($currtag,$currtag_index,$ARGV[$currfile]);
  my $tmptag = $currtag;
  if ($currtag_index == 0) { $tmptag = join '',$tmptag,'x'; }
  elsif ($currtag_index == 1) { $tmptag = join '',$tmptag,'y'; }
  elsif ($currtag_index == 2) { $tmptag = join '',$tmptag,'z'; }
  $plotfile1 = join '',$ARGV[$currfile],'.',$tmptag,'.dat';
  open PLOT1, ">$plotfile1";
  print PLOT1 "\#  $depvarnames[$depvarnum]  $tmptag\n";
  my $tagsize = @tag - 1;
  my $lastionictime = -1;
  my $tmpdt = 0.0;
  my $deltat = 0.0;
  my $cnt1 = 0;
  my $cnt2 = 0;
  my $cnt3 = 0;
  for ($i=0; $i<$tagsize; $i++) {

    my $time = $tag[$i][$depvarnum];
    if ($depvarnum == 1) { $time /= 60; }

    if ($i==0) {
      $xmin = $time;  $xmax = $time;
      $ymin = 0;  $ymax = 0;
    }

    if ($tag[$i][4] eq "ionic") { 
      $tmpdt = 0.0;
      $lastionictime = $time;
      INNER1:  for ($j=$i+1; $j<=$tagsize; $j++) {
        if ($tag[$j][4] eq "ionic") { 
          $newtime = $tag[$j][$depvarnum];
          if ($depvarnum == 1) { $newtime /= 60; }
          $deltat = ($newtime - $lastionictime)/($j-$i);
          last INNER1;
        }
      }
    }
    else {
      $tmpdt += $deltat;
      if ($depvarnum == 1 || $depvarnum == 2) { 
        $time = $lastionictime + $tmpdt;
      }
    }
    printf PLOT1 " %0.8f    %0.10f \n",$time,$tag[$i][3];
  }
  close PLOT1;
  if (! -e $scrollcmd) { $message = "$scrollcmd not found!"; return; }
  system("$scrollcmd $plotfile1");
  unlink $plotfile1;

  print "\nHit return to continue...\n";
  my $input = <STDIN>;

}
########################################################################
sub Print_Header {

  if ($current_prompt eq $submenu_prompt) {
    Print_SubMenu_Header();
  }
  else {
    Print_Main_Menu_Header();
  }

  return;
}
########################################################################
sub Print_Main_Menu_Header {

  print " ***  Qbox Analysis Tool, written by Erik Draeger, LLNL  ***\n";

  if ($nfiles > 1) {
    $tmpcurr = $currfile + 1;
    print "$ARGV[$currfile]:  (file $tmpcurr of $nfiles)\n";
  }
  else {
    print "$ARGV[$currfile]:\n";
  }
  $ncpus = $nprow*$npcol;
  print "  $nplane plane waves, $nstates states on $ncpus cpus ($nprow x $npcol)\n";
  if ($nerrors > 0 || $nwarnings > 0) { 
    print "  $nerrors errors, $nwarnings warnings\n";
  }
  my $runselcnt = 0;
  for ($i=0; $i<$nrun; $i++) { 
    if ($run_selected[$i] == 1) { $runselcnt++; }
  }
  print "  $nrun run statements ($runselcnt selected)\n";
  print "output method:  $output_method[$output_method_selected]->{actionname} $output_method[$output_method_selected]->{description} vs. $depvarnames[$depvarnum]\n";
  if ($currtag_index >=0 && $currtag_index <= 2) { print "tag to analyze:  $currtag ($indexname[$currtag_index] component)\n"; }
  else { print "tag to analyze:  $currtag\n"; }
  print "\n";

  $main_menu{'a'} = "$output_method[$output_method_selected]->{actionname} $currtag vs. $depvarnames[$depvarnum] $output_method[$output_method_selected]->{description}";

}
########################################################################
sub GetFileInfo {
  use POSIX;
  $nerrors = 0;
  $nwarnings = 0;
  $nrun = 0;
  $nmpirun = -1;
  my $firsteig = 0;
  my $firstplane = 0;
  $nplane = 0;
  my ($file) = @_;
  $nprow = 0;
  $npcol = 0;

  open OUT, $file or die "Can't open $file: $!\n";
  OUTLINE: while ($line = <OUT>) {

#    if ($line =~ /<!--\ \[qbox\]/ || $line =~ /<!--\ \[qbLink\]/ ) { 
    if ($line =~ /\[qbox\]/ || $line =~ /\[qbLink\]/ ) { 
      @data = split ' ',$line;
      for ($i=0;$i<=$#data;$i++) {
        if ($data[$i] =~ '[qbox]' || $data[$i] =~ '[qbLink]') {
          if ($data[$i+1] eq 'set' || $data[$i+1] eq '<cmd>set') {         # variables
            my $var = $data[$i+2];
            my $value = $data[$i+3];
            for ($k = $i+4; $k<$#data; $k++) {
              $value = join ' ',$value,$data[$k];
            }
            $input_variables{$var} = $value;

            #ewd DEBUG
            #print "variable $var set to $value\n";
          }
          elsif ($data[$i+1] eq '-->') {      # blank lines
            # do nothing
          }
          else {                              # commands
            $command = $data[$i+1];

            my $args = $data[$i+2];
            for ($k = $i+3; $k<$#data; $k++) {
              $args = join ' ',$args,$data[$k];
            }

# compatibility w. Davis Qbox
            if ($command eq '<cmd>run') {
              $runargs[$nrun] = $args;
              # save current variable configuration
              foreach $key (keys %input_variables) {
                $runvars{$key}[$nrun] = $input_variables{$key};
              }
              $mpirun_map[$nrun] = $nmpirun;
              $nrun++;
            }
          }
        }
      }
    }
    # run tag can occur without an explicit input command when executed by qbLink functions, e.g. runBOSteps
    elsif ($line =~ /<run niter/) {
      @data = split '"',$line;
      my $args = join ' ',$data[1],$data[3],$data[5];
      $runargs[$nrun] = $args;
      # save current variable configuration
      foreach $key (keys %input_variables) {
        $runvars{$key}[$nrun] = $input_variables{$key};
      }
      $mpirun_map[$nrun] = $nmpirun;
      $nrun++;
    }
    elsif ($line =~ /<qbox:simulation/) { 
      $nmpirun++;
    }
    elsif ($line =~ /<ERROR>/) { 
      @tmp1 = split '<ERROR>',$line;
      @tmp2 = split '</ERROR>',$tmp1[1];
      $errorrun[$nerrors] = $nrun;
      $errorlist[$nerrors] = $tmp2[0];
      $nerrors++;
    }
    elsif ($line =~ /<WARNING>/) { 
      @tmp1 = split '<WARNING>',$line;
      @tmp2 = split '</WARNING>',$tmp1[1];
      $warninglist[$nwarnings] = $tmp2[0];
      $warningrun[$nwarnings] = $nrun;
      $nwarnings++;
    }
    elsif ($line =~ /<wavefunction ecut/) {
      @tmp = split '\"',$line;
      $nstates = $tmp[5]/2;
    }
    elsif ($line =~ /<eigenvalues spin/ && $firsteig == 0) {
      $firsteig = 1;
      @tmp = split '\"',$line;
      $nstates = $tmp[5];
    }
#    elsif ($line =~ /<!-- basis size/ && $firstplane == 0) {
    elsif ($line =~ /basis size/ && $firstplane == 0) {
      $firstplane = 1;
      @data = split ' ',$line;
      for ($i=0; $i<=$#data; $i++) {
        if ($data[$i] =~ /basis/) { $nplane = $data[$i+2]; }
      }
    }
    elsif ($line =~ /c dimensions/) {
      @data = split ' ',$line;
      for ($i=0; $i<=$#data; $i++) {
        if ($data[$i] =~ /dimensions/) { 
          my @tmp2 = split 'x',$data[$i+1];
          my $cm = $tmp2[0];
          my $cn = $tmp2[1];
          @tmp2 = split '\(',$data[$i+2];
          my @tmp3 = split 'x',$tmp2[1];
          my $cmloc = $tmp3[0];
          my $cnloc = $tmp3[1];
          $nprow = ceil($cm/$cmloc);
          $npcol = ceil($cn/$cnloc);
        }
      }

    }
    
  }
  close OUT;
}
########################################################################
sub PrintRunSummary {
  my ($file) = @_;

  my $runcnt = -1;
  my $itertime = 0.0;
  my $currdt = 0.0;
  my $convert_au_to_fs = 0.02418885;
  my @itercnt_ionic;
  my @itercnt_scf;
  my @totaltime;
  my @walltime;
  my @mdtime;
  my @scfconv;
  my @release;
  my @npes;
  my @arch;
  my @start_time;
  my @end_time;
  my $currmpirun = -1;
  my @currmpirun_map;

  open OUT, $file or die "Can't open $file: $!\n";
  OUTLINE: while ($line = <OUT>) {
    if ($line =~ /<qbox:simulation/) { 
      $currmpirun++;
      $currdt = 0.0;
      $npes[$currmpirun] = 0;
    }
    elsif ($line =~ /<release>/) { 
      @data = split ' ',$line;
      for ($i=0;$i<=$#data;$i++) {
        if ($data[$i] =~ /<release>/) { 
          @tmp = split ' ',$data[$i+1];
          $release[$currmpirun] = $tmp[0];
          $arch[$currmpirun] = $data[$i+2];
        }
      }
    }
    elsif ($line =~ /<npes>/) { 
      @data = split ' ',$line;
      for ($i=0;$i<=$#data;$i++) {
        if ($data[$i] =~ /<npes>/) { 
          $npes[$currmpirun] = $data[$i+1];
        }
      }
    }
    elsif ($line =~ /<start_time>/) { 
      @data = split ' ',$line;
      for ($i=0;$i<=$#data;$i++) {
        if ($data[$i] =~ /<start_time>/) { 
          @tmp = split 'T',$data[$i+1];
          @tmp2 = split '-',$tmp[0];
          @tmp3 = split ':',$tmp[1];
          $start_time[$currmpirun] = join '',$tmp2[1],"-",$tmp2[2],"-",$tmp2[0]," ",$tmp3[0],':',$tmp3[1];
          $end_time[$currmpirun] = "unset";
        }
      }
    }
    elsif ($line =~ /<end_time>/) { 
      @data = split ' ',$line;
      for ($i=0;$i<=$#data;$i++) {
        if ($data[$i] =~ /<end_time>/) { 
          @tmp = split 'T',$data[$i+1];
          @tmp2 = split '-',$tmp[0];
          @tmp3 = split ':',$tmp[1];
          $end_time[$currmpirun] = join '',$tmp2[1],"-",$tmp2[2],"-",$tmp2[0]," ",$tmp3[0],':',$tmp3[1];
        }
      }
    }
#    elsif ($line =~ /<!--\ \[qbox\]/) { 
    elsif ($line =~ /\[qbox\]/) { 
      @data = split ' ',$line;
      for ($i=0;$i<=$#data;$i++) {
        if ($data[$i] =~ '[qbox]') {
          if ($data[$i+1] eq 'set' || $data[$i+1] eq '<cmd>set') {         # variables
            my $var = $data[$i+2];
            my $value = $data[$i+3];
            for ($k = $i+4; $k<$#data; $k++) {
              $value = join ' ',$value,$data[$k];
            }
            if ($var eq "dt") {
              $currdt = $value;
            }
          }
          elsif ($data[$i+1] eq '-->') {      # blank lines
            # do nothing
          }
          else {                              # commands

#ewd DEBUG
            print "command = $data[$i+1]\n";

            my $command = $data[$i+1];
            my $args = $data[$i+2];
            for ($k = $i+3; $k<$#data; $k++) {
              $args = join ' ',$args,$data[$k];
            }
            if ($command eq "run" || $command eq "<cmd>run") { 
              $runcnt++; 
              $itercnt_ionic[$runcnt] = 0;
              $itercnt_scf[$runcnt] = 0;
              $totaltime[$runcnt] = 0;
              $mdtime[$runcnt] = 0;
              $walltime[$runcnt] = 0;
              $scfconv[$runcnt] = 0;
              $currmpirun_map[$runcnt] = $currmpirun;
            }
          }
        }
      }
    }
    elsif ($line =~ /start scf iteration/) { 
      $itercnt_scf[$runcnt]++;
    }
    elsif ($line =~ /scf convergence reached/) { 
      $scfconv[$runcnt] = 1;
    }
    elsif ($line =~ /<\/iteration/) { 
      $itercnt_ionic[$runcnt]++;
      $mdtime[$runcnt] += $currdt*$convert_au_to_fs;
    }
    elsif ($line =~ /timing/ && $line =~ /iteration/) { 
      @data = split ' ',$line;
      for ($i=0;$i<=$#data;$i++) {
        if ($data[$i] =~ "iteration") {
          $itertime = $data[$i+4];
          chop $itertime; chop $itertime; chop $itertime; 
        }
      }
      $walltime[$runcnt] += $itertime;
    }
  }
  close OUT;

  my @first;
  for ($k=0; $k<=$currmpirun; $k++) { $first[$k] = 0; }

  $tmprand = rand(99999999999);
  $tmpmorefile = join '',$file,".",$tmprand,".tmp";
  open TMPMORE, ">$tmpmorefile" or die  "Can't open $tmpmorefile: $!\n";

  ###  finished reading output file, now print run summary  ###
  for ($k=0; $k<=$currmpirun; $k++) {
    my $kk = $k+1;
    print TMPMORE "\n----------------------------------------------------------------------\n";
    $tmpnpes = '';
    if ($npes[$k] > 0) { $tmpnpes = " $npes[$k] cpus,"; }
    print TMPMORE "mpirun \#$kk: $tmpnpes $start_time[$k], qbox $release[$k], $arch[$k]\n";
    print TMPMORE "----------------------------------------------------------------------\n";
    for ($r=0; $r<=$runcnt; $r++) {
      if ($currmpirun_map[$r] == $k) {

        if ($first[$k] == 0) { 
          $first[$k] = 1;

          foreach $v ("wf_dyn", "atoms_dyn", "cell_dyn") {
            if (!defined($runvars{$v}[$r])) { $tmp = "(not set)"; }
            else { $tmp = $runvars{$v}[$r]; }
            print TMPMORE "$v=$tmp  ";
          }
          if (defined($runvars{"atoms_dyn"}[$r]) || defined($runvars{"cell_dyn"}[$r])) {
            $v = "dt";
            if (!defined($runvars{$v}[$r])) { $tmp = "(not set)"; }
            else { $tmp = $runvars{$v}[$r]; }
            print TMPMORE "$v=$tmp  ";
          }
          print TMPMORE "\n";
          
          foreach $v ("ecut", "ecutprec", "nkpoints", "nempty") {
            if (!defined($runvars{$v}[$r])) { $tmp = "(not set)"; }
            else { $tmp = $runvars{$v}[$r]; }
            print TMPMORE "$v=$tmp  ";
          }
          print TMPMORE "\n";
          print TMPMORE "  run $runargs[$r] "; 
        
          $time = $walltime[$r]/60;
          printf TMPMORE ":   %0.2f min",$time;
        
          my @runsplit = split ' ',$runargs[$r];
          my $nionic = $runsplit[0];
          my $nscf = $runsplit[1];
          if ($itercnt_ionic[$r] < $nionic && $itercnt_ionic[$r] > 0) {
            print TMPMORE " ($itercnt_ionic[$r] ionic steps, not finished)";
          }
          if ($scfconv[$r] == 1) {
            my $avgscf = $itercnt_scf[$r]/$itercnt_ionic[$r];
            my @tmpsplit = split ' ',$runvars{threshold_scf}[$r];
            my $threshold = $tmpsplit[0];
            if ($#tmpsplit == 0) { $nsteps = 2; }
            else { $nsteps = $tmpsplit[1]; }
            printf TMPMORE "\n    avg. \# scf steps to reach threshold:  %0.1f steps",$avgscf;
          }
          elsif ($itercnt_scf[$r] < $nscf) { 
            print TMPMORE " ($itercnt_scf[$r] scf steps, not finished)";
          }
        
          if ($itercnt_ionic[$r] > 1) { 
            my $avgtime = $time/$itercnt_ionic[$r];
            printf TMPMORE "\n    avg. time/ionic iteration:  %0.2f min",$avgtime;
          }
        
          print TMPMORE "\n";
        }
        else {   # second run statement
          foreach $v ("ecut", "ecutprec", "nempty", "fermi_temp", "smearing", "atoms_dyn", "dt", "thermostat", "th_time", "th_temp", "cell_dyn", "stress", "ecuts", "cell_lock") {
            if (defined($runvars{$v}[$r])) {
              if (!defined($runvars{$v}[$r-1])) {
                print TMPMORE "    $v set to $runvars{$v}[$r]\n";
              }
              elsif ($runvars{$v}[$r] ne $runvars{$v}[$r-1]) { 
                print TMPMORE "    $v changed to $runvars{$v}[$r]\n";
              }
            }
          }

          print TMPMORE "  run $runargs[$r] "; 
        
          $time = $walltime[$r]/60;
          printf TMPMORE ":   %0.2f min",$time;
        
          my @runsplit = split ' ',$runargs[$r];
          my $nionic = $runsplit[0];
          my $nscf = $runsplit[1];
          if ($itercnt_ionic[$r] < $nionic && $itercnt_ionic[$r] > 0) {
            print TMPMORE " ($itercnt_ionic[$r] ionic steps, not finished)";
          }
          if ($scfconv[$r] == 1) {
            my $avgscf = $itercnt_scf[$r]/$itercnt_ionic[$r];
            my @tmpsplit = split ' ',$runvars{threshold_scf}[$r];
            my $threshold = $tmpsplit[0];
            if ($#tmpsplit == 0) { $nsteps = 2; }
            else { $nsteps = $tmpsplit[1]; }
            printf TMPMORE "\n    avg. \# scf steps to reach threshold:  %0.1f steps",$avgscf;
          }
          elsif ($itercnt_scf[$r] < $nscf) { 
            print TMPMORE " ($itercnt_scf[$r] scf steps, not finished)";
          }
        
          if ($itercnt_ionic[$r] > 1) { 
            my $avgtime = $time/$itercnt_ionic[$r];
            printf TMPMORE "\n    avg. time/ionic iteration:  %0.2f min",$avgtime;
          }
        
          print TMPMORE "\n";
        }
      }
    }
  }
  close TMPMORE;
  if (! -e $scrollcmd) { $message = "$scrollcmd not found!"; return; }
  system ("$scrollcmd $tmpmorefile");
  unlink $tmpmorefile;

  print "\nHit return to continue...\n";
  my $input = <STDIN>;
}
########################################################################
sub PrintTimingSummary {
  my ($file) = @_;

  my $runcnt = -1;
  my $itertime = 0.0;
  my $currdt = 0.0;
  my $convert_au_to_fs = 0.02418885;
  my @itercnt_ionic;
  my @itercnt_scf;
  my @totaltime;
  my @walltime;
  my @mdtime;
  my @scfconv;

  open OUT, $file or die "Can't open $file: $!\n";
  OUTLINE: while ($line = <OUT>) {
    if ($line =~ /<qbox:simulation/) { 
      $currdt = 0.0;
    }
#    elsif ($line =~ /<!--\ \[qbox\]/) { 
    elsif ($line =~ /\[qbox\]/) { 
      @data = split ' ',$line;
      for ($i=0;$i<=$#data;$i++) {
        if ($data[$i] =~ '[qbox]') {
          if ($data[$i+1] eq 'set') {         # variables
            my $var = $data[$i+2];
            my $value = $data[$i+3];
            for ($k = $i+4; $k<$#data; $k++) {
              $value = join ' ',$value,$data[$k];
            }
            if ($var eq "dt") {
              $currdt = $value;
            }
          }
          elsif ($data[$i+1] eq '-->') {      # blank lines
            # do nothing
          }
          else {                              # commands
            my $command = $data[$i+1];
            my $args = $data[$i+2];
            for ($k = $i+3; $k<$#data; $k++) {
              $args = join ' ',$args,$data[$k];
            }
            if ($command eq "run") { 
              $runcnt++; 
              $itercnt_ionic[$runcnt] = 0;
              $itercnt_scf[$runcnt] = 0;
              $totaltime[$runcnt] = 0;
              $mdtime[$runcnt] = 0;
              $walltime[$runcnt] = 0;
              $scfconv[$runcnt] = 0;
            }
          }
        }
      }
    }
    elsif ($line =~ /start scf iteration/) { 
      $itercnt_scf[$runcnt]++;
    }
    elsif ($line =~ /scf convergence reached/) { 
      $scfconv[$runcnt] = 1;
    }
    elsif ($line =~ /<\/iteration/) { 
      $itercnt_ionic[$runcnt]++;
      $mdtime[$runcnt] += $currdt*$convert_au_to_fs;
    }
    elsif ($line =~ /timing/ && $line =~ /iteration/) { 
      @data = split ' ',$line;
      for ($i=0;$i<=$#data;$i++) {
        if ($data[$i] =~ "iteration") {
          $itertime = $data[$i+4];
          chop $itertime; chop $itertime; chop $itertime; 
        }
      }
      $walltime[$runcnt] += $itertime;
    }
  }
  close OUT;

  $tmprand = rand(99999999999);
  $tmpmorefile = join '',$file,".",$tmprand,".tmp";
  open TMPMORE, ">$tmpmorefile" or die  "Can't open $tmpmorefile: $!\n";

  ###  finished reading output file, now print run summary  ###
  for ($r=0; $r<=$runcnt; $r++) {
    print TMPMORE "\n---------------------------------------------------\n";

    foreach $v ("wf_dyn", "atoms_dyn", "cell_dyn") {
      if (!defined($runvars{$v}[$r])) { $tmp = "(not set)"; }
      else { $tmp = $runvars{$v}[$r]; }
      print TMPMORE "$v=$tmp  ";
    }
    if (defined($runvars{"atoms_dyn"}[$r]) || defined($runvars{"cell_dyn"}[$r])) {
      $v = "dt";
      if (!defined($runvars{$v}[$r])) { $tmp = "(not set)"; }
      else { $tmp = $runvars{$v}[$r]; }
      print TMPMORE "$v=$tmp  ";
    }
    print TMPMORE "\n";
    
    foreach $v ("ecut", "ecutprec", "nkpoints", "nempty") {
      if (!defined($runvars{$v}[$r])) { $tmp = "(not set)"; }
      else { $tmp = $runvars{$v}[$r]; }
      print TMPMORE "$v=$tmp  ";
    }
    print TMPMORE "\n";
    print TMPMORE "run $runargs[$r] "; 

    $time = $walltime[$r]/60;
    printf TMPMORE ":   %0.2f min",$time;

    my @runsplit = split ' ',$runargs[$r];
    my $nionic = $runsplit[0];
    my $nscf = $runsplit[1];
    if ($itercnt_ionic[$r] < $nionic && $itercnt_ionic[$r] > 0) {
      print TMPMORE " ($itercnt_ionic[$r] ionic steps, not finished)";
    }
    if ($scfconv[$r] == 1) {
      my $avgscf = $itercnt_scf[$r]/$itercnt_ionic[$r];
      my @tmpsplit = split ' ',$runvars{threshold_scf}[$r];
      my $threshold = $tmpsplit[0];
      if ($#tmpsplit == 0) { $nsteps = 2; }
      else { $nsteps = $tmpsplit[1]; }
      printf TMPMORE "\n  avg. \# scf steps to reach threshold:  %0.1f steps",$avgscf;
    }
    elsif ($itercnt_scf[$r] < $nscf) { 
      print TMPMORE " ($itercnt_scf[$r] scf steps, not finished)";
    }

    if ($itercnt_ionic[$r] > 1) { 
      my $avgtime = $time/$itercnt_ionic[$r];
      printf TMPMORE "\n  avg. time/ionic iteration:  %0.2f min",$avgtime;
    }

    print TMPMORE "\n";
  }
  close TMPMORE;
  if (! -e $scrollcmd) { $message = "$scrollcmd not found!"; return; }
  system ("$scrollcmd $tmpmorefile");
  unlink $tmpmorefile;

  print "\nHit return to continue...\n";
  my $input = <STDIN>;

}
########################################################################
sub GetTagFromFile {
  # usage:  @tag = GetTagFromFile($tagname,$index);
  #   index = -1 if scalar,  0-2 if vector
  # output:  
  #   $tag[$i][0] = tagcnt
  #   $tag[$i][1] = wall time (min)
  #   $tag[$i][2] = MD time (fs)   
  #   $tag[$i][3] = tag value                           
  #   $tag[$i][4] = iteration type (ionic, scf, non-scf)

  my ($gettag,$index,$file) = @_;

  my $currdt = 0.0;
  my $tagcnt = 0;
  my @tagval;
  my $runcnt = -1;
  my $in_ionic = -1;
  my $in_scf = -1;
  my $in_nonscf = -1;
  my $mdtime = 0.0;
  my $lastwalltime = 0.0;
  my $walltime = 0.0;
  my $itertime = 0.0;
  my $convert_au_to_fs = 0.02418885;

  open OUT, $file or die "Can't open $file: $!\n";
  OUTLINE: while ($line = <OUT>) {
    if ($line =~ /<qbox:simulation/) { 
      $currdt = 0.0;
    }
#    elsif ($line =~ /<!--\ \[qbox\]/) { 
    elsif ($line =~ /\[qbox\]/) { 
      @data = split ' ',$line;
      for ($i=0;$i<=$#data;$i++) {
        if ($data[$i] =~ '[qbox]') {
          if ($data[$i+1] eq 'set') {         # variables
            my $var = $data[$i+2];
            my $value = $data[$i+3];
            for ($k = $i+4; $k<$#data; $k++) {
              $value = join ' ',$value,$data[$k];
            }
            if ($var eq "dt") {
              $currdt = $value;
            }
          }
          elsif ($data[$i+1] eq '-->') {      # blank lines
            # do nothing
          }
          else {                              # commands
            my $command = $data[$i+1];
            my $args = $data[$i+2];
            for ($k = $i+3; $k<$#data; $k++) {
              $args = join ' ',$args,$data[$k];
            }

            if ($command eq "run") {
              $runcnt++;
            }
          }
        }
      }
    }
    elsif ($line =~ /<iteration count/) { 
      $in_ionic = 1;
      $in_scf = 0;
      $in_nonscf = 0;
    }
    elsif ($line =~ /start scf iteration/) { 
      $in_nonscf = 0;
      if ($in_ionic == 1) { $in_scf = 0; } # for etotal_int, eigenvalue_sum, print first
      else { $in_scf = 1; }                # scf value as ionic
    }
    elsif ($line =~ /<\/iteration/) { 
      $mdtime += $currdt*$convert_au_to_fs;
    }
    elsif ($line =~ /timing/ && $line =~ /iteration/) { 
      @data = split ' ',$line;
      for ($i=0;$i<=$#data;$i++) {
        if ($data[$i] =~ "iteration") {
          $itertime = $data[$i+4];
          chop $itertime; chop $itertime; chop $itertime; 
        }
      }
      $lastwalltime = $walltime;
      $walltime += $itertime;
    }
    if ($line =~ /<$currtag>/ && $run_selected[$runcnt] == 1) { 
      @data = split ' ',$line;
      for ($i=0;$i<=$#data;$i++) {
        if ($data[$i] =~ /<$currtag>/) {
          $tagval[$tagcnt][0] = $tagcnt+1;
          if ($index < 0) {
            $tagval[$tagcnt][3] = $data[$i+1];
          }
          else {
            $tagval[$tagcnt][3] = $data[$i+1+$index];
          }
          if ($in_ionic == 1) { 
            $tagval[$tagcnt][4] = "ionic";
            $in_ionic = 0;
            $tagval[$tagcnt][1] = $walltime;
            $tagval[$tagcnt][2] = $mdtime;
          }
          elsif ($in_scf == 1) { 
            $tagval[$tagcnt][4] = "scf";
            $in_scf = 0;
            $in_nonscf = 1;
          }
          else {
            $tagval[$tagcnt][4] = "nonscf";
          }
          $tagcnt++;
        }
      }
    }
  }
  $tagval[$tagcnt][0] = 0.0;
  $tagval[$tagcnt][1] = $walltime;
  $tagval[$tagcnt][2] = $mdtime;
  $tagval[$tagcnt][3] = 0.0;
  $tagval[$tagcnt][4] = "ionic";
  close OUT;
  return (@tagval);

}
########################################################################
sub Clear_Screen {
    if ($^O =~ /MSWin/) { system('cls'); }    # Win* platforms
    else { system('clear'); }  # Assume it's a Unix/Linux/cygwin platform
}

########################################################################
#-----------------------------------------------------------------------
# Subroutine : Pick_From_Menu(%)
# Purpose    : Generic and flexible subroutine for creating a menu
#              using a hash as the menu items.
# Notes      : Call with named aggregate notation. Aside from 'menu',
#              all arguments are optional. 'menu' must be given a hash
#              reference, not a hash!
#-----------------------------------------------------------------------
sub Pick_From_Menu {
    my %args = (
        # Default parameter values
        confirm        => 0, # 0 -> Return on first valid response
                             # 1 -> Confirm selection before returning
        max_errors     => 10, # N -> Give up after N invalid choices
        clear_on_err   => 1, # 0 -> Just keep streaming down the screen
                             # 1 -> Clear screen on error/next page
        sort_by_values => 0, # 0 -> Display items sorted by hash keys
                             # 1 -> Display items sorted by hash values
        numeric_keys   => 0, # 0 -> Sort keys numerically
                             # 1 -> Sort keys alphabetically
        use_keylist    => 0, # 0 -> No input keylist
                             # @keylist -> use this keylist, in given order
        max_display    => 0, # 0 -> Display the full menu
                             # N -> Display menu N items at a time
        return_key     => 1, # 0 -> Returns hash value
                             # 1 -> Returns hash key
        prompt         => 'Please make a selection:',
        menu           => undef,
        @_);
    my @list;
    my $count;
    my $response;
    my $returnval;
    my ($first_item, $last_item);
    my $select_prompt;

    die ('No menu to pick from') unless ref($args{menu}) eq 'HASH';

    if ($args{use_keylist} == 0) {
    
      if ($args{sort_by_values}) {
        @list = sort {$args{menu}->{$a} cmp $args{menu}->{$b}}
                     keys %{$args{menu}};
      }
      elsif ($args{numeric_keys}) {
        @list = sort {$a <=> $b} keys %{$args{menu}};
      }
      else {
        @list = sort {$a cmp $b} keys %{$args{menu}};
      }
    }
    else {
      @list = @{ $args{use_keylist} };
    }

    # If the caller didn't specify a maximum number of menu items to
    # display at a time, default to the number of items in the menu.
    $args{max_display} ||= @list;

    #-------------------------------------------------
    # Initializes limits on menu items to be displayed
    #-------------------------------------------------
    my $Init_Disp_Limits = sub {
        $first_item = 0;
        if ($args{max_display} < @list) {
            $last_item = $args{max_display} - 1;
            $select_prompt = 'Selection (ENTER for more): ';
        }
        else {
            $last_item = $#list;
            $select_prompt = 'Selection: ';
        }
    };

    $Init_Disp_Limits->();

    for ($count = 0; $count < $args{max_errors}; $count++) {

        printf ("%s\n", $args{prompt});
        foreach ($first_item .. $last_item) {
            printf ("%3s - %s\n", $list[$_], $args{menu}->{$list[$_]});
        }
        print "\n";

        print $select_prompt;
        $response = <STDIN>;
        chomp $response;

        if ($response =~ /^\s*$/) {
            if ($last_item >= $#list) {
                $Init_Disp_Limits->();
            }
            else {
                $first_item = $last_item + 1;
                if ($#list > $last_item + $args{max_display}) {
                    $last_item += $args{max_display};
                }
                else {
                    $last_item = $#list;
                }
            }
            if ($args{clear_on_err}) {
              Clear_Screen();
              Print_Header();
            }
            #Clear_Screen() if $args{clear_on_err};
            redo;
        }

        if (defined $args{menu}->{$response}) {
            $returnval = ($args{return_key})
                ? $response
                : $args{menu}->{$response};
            if ($args{confirm}) {
                print "Selection = $response\n";
                print 'Is this correct? [Y]/N : ';
                my $confirm = <STDIN>;
                if ($confirm =~ /^(y|\n)/i) {
                    return ($returnval);
                }
                else {
                    $Init_Disp_Limits->();
                    $count = 0;
                    if ($args{clear_on_err}) {
                      Clear_Screen();
                      Print_Header();
                    }
                    #Clear_Screen() if ($args{clear_on_err});
                    redo;
                }
            }
            else {
                return ($returnval);
            }
        }
        else {
            if ($args{clear_on_err}) {
              Clear_Screen();
              Print_Header();
            }
            #Clear_Screen() if ($args{clear_on_err});
            print "Your response '$response' is not valid.\n\n";
            $Init_Disp_Limits->();
        }
    }
    print "Too many invalid attempts. Exiting.\n";
    exit;
} # END Pick_From_Menu()

########################################################################
